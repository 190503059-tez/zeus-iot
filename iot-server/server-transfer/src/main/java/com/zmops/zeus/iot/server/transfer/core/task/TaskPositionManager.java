package com.zmops.zeus.iot.server.transfer.core.task;


import com.zmops.zeus.iot.server.transfer.common.AbstractDaemon;
import com.zmops.zeus.iot.server.transfer.conf.JobProfile;
import com.zmops.zeus.iot.server.transfer.core.TransferManager;
import com.zmops.zeus.iot.server.transfer.core.db.JobProfileDb;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import static com.zmops.zeus.iot.server.transfer.conf.CommonConstants.POSITION_SUFFIX;

/**
 * used to store task position to db, task position is stored as properties in JobProfile.
 * where key is task read file name and value is task sink position
 * note that this class is generated
 */
public class TaskPositionManager extends AbstractDaemon {

    private static final Logger LOGGER = LoggerFactory.getLogger(TaskPositionManager.class);

    public static final int DEFAULT_FLUSH_TIMEOUT = 3;

    private final TransferManager transferManager;
    private final JobProfileDb    jobConfDb;

    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Long>> jobTaskPositionMap;

    private static volatile TaskPositionManager taskPositionManager = null;

    private TaskPositionManager(TransferManager transferManager) {
        this.transferManager = transferManager;
        this.jobConfDb = transferManager.getJobManager().getJobConfDb();
        this.jobTaskPositionMap = new ConcurrentHashMap<>();
    }

    /**
     * task position manager singleton, can only generated by agent manager
     *
     * @param transferManager
     * @return
     */
    public static TaskPositionManager getTaskPositionManager(TransferManager transferManager) {
        if (taskPositionManager == null) {
            synchronized (TaskPositionManager.class) {
                if (taskPositionManager == null) {
                    taskPositionManager = new TaskPositionManager(transferManager);
                }
            }
        }
        return taskPositionManager;
    }

    /**
     * get taskPositionManager singleton
     *
     * @return
     */
    public static TaskPositionManager getTaskPositionManager() {
        if (taskPositionManager == null) {
            throw new RuntimeException("task position manager has not been initialized by agentManager");
        }
        return taskPositionManager;
    }

    @Override
    public void start() throws Exception {
        submitWorker(taskPositionFlushThread());
    }

    /**
     * 定时存储到本地DB
     *
     * @return
     */
    private Runnable taskPositionFlushThread() {
        return () -> {
            while (isRunnable()) {
                try {
                    // check pending jobs and try to submit again.
                    for (String jobId : jobTaskPositionMap.keySet()) {
                        JobProfile jobProfile = jobConfDb.getJobProfile(jobId);
                        if (jobProfile == null) {
                            LOGGER.warn("jobProfile {} cannot be found in db, "
                                    + "might be deleted by standalone mode, now delete job position in memory", jobId);
                            deleteJobPosition(jobId);
                            continue;
                        }
                        flushJobProfile(jobId, jobProfile);
                    }
                    TimeUnit.SECONDS.sleep(DEFAULT_FLUSH_TIMEOUT);
                } catch (Exception ex) {
                    LOGGER.error("error caught", ex);
                }
            }
        };
    }

    private void flushJobProfile(String jobId, JobProfile jobProfile) {
        jobTaskPositionMap.get(jobId).forEach(
                (fileName, position) -> {
                    jobProfile.setLong(fileName + POSITION_SUFFIX, position);
                }
        );
        if (jobConfDb.checkJobfinished(jobProfile)) {
            LOGGER.info("Cannot update job profile {}, delete memory job in jobTaskPosition", jobId);
            deleteJobPosition(jobId);
        } else {
            jobConfDb.updateJobProfile(jobProfile);
        }
    }

    private void deleteJobPosition(String jobId) {
        jobTaskPositionMap.remove(jobId);
    }

    @Override
    public void stop() throws Exception {
        waitForTerminate();
    }

    /**
     * 更新 文件读取位置
     *
     * @param jobInstanceId  任务实例ID
     * @param sourceFilePath 源文件路径
     * @param size           position
     */
    public void updateFileSinkPosition(String jobInstanceId, String sourceFilePath, long size) {
        ConcurrentHashMap<String, Long> filePositionTemp = new ConcurrentHashMap<>();

        ConcurrentHashMap<String, Long> filePosition = jobTaskPositionMap.putIfAbsent(jobInstanceId, filePositionTemp);

        long beforePosition;

        if (filePosition == null) {
            filePosition = filePositionTemp;
            beforePosition = jobConfDb.getJobProfile(jobInstanceId).getLong(sourceFilePath + POSITION_SUFFIX, 0);
        } else {
            beforePosition = filePosition.getOrDefault(sourceFilePath, 1L);
        }

        filePosition.put(sourceFilePath, beforePosition + size);
    }

    public ConcurrentHashMap<String, Long> getTaskPositionMap(String jobId) {
        return jobTaskPositionMap.get(jobId);
    }

    public ConcurrentHashMap<String, ConcurrentHashMap<String, Long>> getJobTaskPosition() {
        return jobTaskPositionMap;
    }
}
